<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>GEP&Padel — Tablero</title>
  <meta name="theme-color" content="#111111" />
  <link rel="manifest" href="./manifest.webmanifest">
  <link rel="icon" href="./favicon.ico">
  <link rel="apple-touch-icon" href="./icon-192.png">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .cell-win{ font-weight:700; }
    .avatar{ width:28px;height:28px;border-radius:9999px;object-fit:cover;border:1px solid #e5e7eb;background:#fff }
    .row:hover{ background:#fafafa }
    .pick-active{ background:#111; color:#fff; border-color:#111; }
    .pick-active img{ border-color:#111; }
    .btn-soft{ background:#f5f5f5; border:1px solid #e5e7eb; border-radius:12px; padding:.5rem .9rem; }
    .btn-soft:hover{ background:#eee; }
    .btn-dark{ background:#111; color:#fff; border-radius:12px; padding:.6rem 1rem; }
    @keyframes spin { to { transform: rotate(360deg); } }
    .animate-spin{ animation: spin 1.1s linear infinite; }
  </style>
</head>
<body class="bg-neutral-50">
  <div id="root" class="max-w-6xl mx-auto p-4"></div>

  <script>
    // ---------------- API ----------------
    const API = {
      get key(){ return localStorage.getItem('gep_api_key') || ''; },
      set key(v){ localStorage.setItem('gep_api_key', v || ''); },
      headers(){ const h={'content-type':'application/json'}; const k=this.key; if(k) h['x-api-key']=k; return h; },
      async get(p){ const r=await fetch(p,{headers:this.headers()}); if(!r.ok) throw new Error(await r.text()); return r.json(); },
      async post(p,b){ const r=await fetch(p,{method:'POST',headers:this.headers(),body:JSON.stringify(b||{})}); if(!r.ok) throw new Error(await r.text()); return r.json(); },
      async put(p,b){ const r=await fetch(p,{method:'PUT',headers:this.headers(),body:JSON.stringify(b||{})}); if(!r.ok) throw new Error(await r.text()); return r.json(); },
    };
    const $=s=>document.querySelector(s);
    const T=html=>{const t=document.createElement('template'); t.innerHTML=html.trim(); return t.content.firstChild;};

    // ---------------- Utils ----------------
    const AVA_FALLBACK = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAALElEQVQokWP8//8/AyWYgQEDYwMDA2EQJgZoYQxUM0GMg0GG0wGJQGgYAAAUyQJ0T+eG9wAAAABJRU5ErkJggg==';
    const COURTS = [
      { id:'padel1', name:'Padel 1 Sabadell', email:'info@padel1.com' },
      { id:'test', name:'Pista Test', email:'julio@gepgroup.es' },
    ];
    const escAttr = (v='') => String(v).replace(/&/g,'&amp;').replace(/"/g,'&quot;');

    function miniAvatar(ph,name){
      const src = ph || '/icon-192.png';
      return `<img class="avatar" src="${src}" onerror="this.src='${AVA_FALLBACK}'" alt="${name||''}" />`;
    }
    const formatDT = iso => iso ? new Date(iso).toLocaleString() : 'Sin fecha';
    const formatDateParts = (iso) => {
      if (!iso) {
        const now = new Date();
        return {
          date: now.toLocaleDateString('es-ES', { weekday:'long', year:'numeric', month:'long', day:'numeric' }),
          time: now.toLocaleTimeString('es-ES', { hour:'2-digit', minute:'2-digit' })
        };
      }
      const d = new Date(iso);
      return {
        date: d.toLocaleDateString('es-ES', { weekday:'long', year:'numeric', month:'long', day:'numeric' }),
        time: d.toLocaleTimeString('es-ES', { hour:'2-digit', minute:'2-digit' })
      };
    };

    const formatDateForInput = (iso) => {
      if (!iso) return '';
      const d = new Date(iso);
      if (Number.isNaN(d.getTime())) return '';
      const pad = (v) => String(v).padStart(2, '0');
      return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}`;
    };

    const isPastMatch = (iso) => {
      if (!iso) return false;
      const d = new Date(iso);
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      return d < today;
    };

    const pairKey = (a, b) => [String(a ?? ''), String(b ?? '')].sort().join('|');

    async function compressImage(file, maxW = 1200, quality = 0.85){
      const img = new Image();
      const url = URL.createObjectURL(file);
      await new Promise(res => { img.onload = res; img.src = url; });
      const scale = Math.min(1, maxW / img.width);
      const canvas = document.createElement('canvas');
      canvas.width = Math.max(1, Math.round(img.width * scale));
      canvas.height = Math.max(1, Math.round(img.height * scale));
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      return canvas.toDataURL('image/jpeg', quality);
    }

    async function spin(btn, task) {
      if (!btn) return task();
      const html = btn.innerHTML;
      const w = btn.offsetWidth;
      btn.style.width = w + 'px';
      btn.disabled = true;
      btn.innerHTML = `<img src="./icon-192.png" class="h-5 w-5 animate-spin mx-auto" alt="">`;
      try { return await task(); }
      finally { btn.disabled = false; btn.style.width=''; btn.innerHTML = html; }
    }

    const parseError = (err) => {
      if (!err) return 'Error desconocido';
      const raw = err.message || err.toString();
      try {
        const data = JSON.parse(raw);
        if (data && data.error) return data.error;
      } catch (_) {}
      return raw || 'Error desconocido';
    };

    function openTextModal({ title, defaultValue, confirmLabel = 'Enviar' }) {
      return new Promise((resolve) => {
        const modal = T(`
          <div class="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-2xl shadow-xl w-full max-w-xl p-5 grid gap-3">
              <h3 class="text-lg font-semibold">${title}</h3>
              <textarea class="border rounded-xl px-3 py-2 min-h-[180px]" data-modal-text></textarea>
              <div class="flex justify-end gap-2">
                <button type="button" class="btn-soft" data-modal-cancel>Cancelar</button>
                <button type="button" class="btn-dark" data-modal-ok>${confirmLabel}</button>
              </div>
            </div>
          </div>`);
        const textarea = modal.querySelector('[data-modal-text]');
        textarea.value = defaultValue || '';
        const onKey = (ev) => {
          if (ev.key === 'Escape') {
            ev.preventDefault();
            cleanup(null);
          }
        };
        const cleanup = (val) => {
          document.removeEventListener('keydown', onKey);
          modal.remove();
          resolve(val);
        };
        modal.querySelector('[data-modal-cancel]').onclick = () => cleanup(null);
        modal.querySelector('[data-modal-ok]').onclick = () => cleanup(textarea.value.trim());
        modal.addEventListener('click', (ev) => { if (ev.target === modal) cleanup(null); });
        document.addEventListener('keydown', onKey);
        document.body.appendChild(modal);
        setTimeout(()=>textarea.focus(), 30);
      });
    }

    async function loadAll(){
      const [players,matches,standAll]=await Promise.all([
        API.get('/.netlify/functions/list-players'),
        API.get('/.netlify/functions/list-matches'),
        API.get('/.netlify/functions/standings'),
      ]);
      return {players,matches,standAll};
    }

    function computeMatchSuggestions(players, matches, standAll){
      const validPlayers = Array.isArray(players) ? players.filter(p => p && p.id != null) : [];
      if (validPlayers.length < 4) return [];

      const busyPlayers = new Set();
      (Array.isArray(matches) ? matches : []).forEach(m => {
        if (!m || m.finalizado) return;
        [m.a1, m.a2, m.b1, m.b2].forEach(id => {
          if (id === null || id === undefined) return;
          busyPlayers.add(String(id));
        });
      });

      const availablePlayers = validPlayers.filter(p => !busyPlayers.has(String(p.id)));

      const individualList = (standAll && Array.isArray(standAll.individual)) ? standAll.individual : [];
      const pairList = (standAll && Array.isArray(standAll.parejas)) ? standAll.parejas : [];

      const toNumber = (value) => {
        if (typeof value === 'number' && !Number.isNaN(value)) return value;
        const parsed = Number(value);
        return Number.isNaN(parsed) ? 0 : parsed;
      };

      const individuals = new Map(individualList.map(row => [String(row.id), row]));
      const pairs = new Map(pairList.map(row => [pairKey(row.a, row.b), row]));

      const eligiblePlayers = availablePlayers.filter(p => {
        const data = individuals.get(String(p.id));
        if (!data) return false;
        const matchesPlayed = Math.max(0, toNumber(data.pj));
        const gepto = toNumber(data.geptomic);
        return matchesPlayed > 0 && gepto > 0;
      });

      if (eligiblePlayers.length < 4) return [];

      const playerCache = new Map();
      const pairCache = new Map();

      const getPlayerMetric = (id) => {
        const key = String(id);
        if (playerCache.has(key)) return playerCache.get(key);
        const row = individuals.get(key) || {};
        const geptoRaw = toNumber(row.geptomic);
        const gepto = geptoRaw > 0 ? geptoRaw : 4;
        const matchesPlayed = Math.max(0, toNumber(row.pj));
        const wins = Math.max(0, toNumber(row.pg));
        const puntos = Math.max(0, toNumber(row.puntos));
        const gamesFor = toNumber(row.jg);
        const gamesAgainst = toNumber(row.jp);
        const diffGames = gamesFor - gamesAgainst;
        const winRate = matchesPlayed > 0 ? wins / matchesPlayed : 0.5;
        const setsPerMatch = matchesPlayed > 0 ? puntos / matchesPlayed : 0;
        const diffPerMatch = matchesPlayed > 0 ? diffGames / Math.max(matchesPlayed, 1) : 0;
        const rating = gepto * 0.65 + winRate * 0.25 + setsPerMatch * 0.05 + diffPerMatch * 0.03 + matchesPlayed * 0.02;
        const metric = { gepto, rating, winRate, setsPerMatch, diffPerMatch, matches: matchesPlayed };
        playerCache.set(key, metric);
        return metric;
      };

      const getPairMetric = (id1, id2) => {
        const key = pairKey(id1, id2);
        if (pairCache.has(key)) return pairCache.get(key);
        const row = pairs.get(key) || {};
        const p1 = getPlayerMetric(id1);
        const p2 = getPlayerMetric(id2);
        const geptoRaw = toNumber(row.geptomic);
        const gepto = geptoRaw > 0 ? geptoRaw : (p1.gepto + p2.gepto) / 2;
        const matchesPlayed = Math.max(0, toNumber(row.pj));
        const wins = Math.max(0, toNumber(row.pg));
        const puntos = Math.max(0, toNumber(row.puntos));
        const gamesFor = toNumber(row.jg);
        const gamesAgainst = toNumber(row.jp);
        const diffGames = gamesFor - gamesAgainst;
        const winRate = matchesPlayed > 0 ? wins / Math.max(matchesPlayed, 1) : (p1.winRate + p2.winRate) / 2;
        const setsPerMatch = matchesPlayed > 0 ? puntos / Math.max(matchesPlayed, 1) : (p1.setsPerMatch + p2.setsPerMatch) / 2;
        const diffPerMatch = matchesPlayed > 0 ? diffGames / Math.max(matchesPlayed, 1) : (p1.diffPerMatch + p2.diffPerMatch) / 2;
        const avgPlayerRating = (p1.rating + p2.rating) / 2;
        const synergyGap = Math.abs(p1.rating - p2.rating);
        const strength = gepto * 0.55 + avgPlayerRating * 0.3 + winRate * 0.1 + setsPerMatch * 0.03 + diffPerMatch * 0.02 + matchesPlayed * 0.01;
        const metric = { gepto, strength, synergyGap, matches: matchesPlayed, avgPlayerRating };
        pairCache.set(key, metric);
        return metric;
      };

      const suggestions = [];
      const list = eligiblePlayers.slice();
      const total = list.length;
      for (let i = 0; i < total - 3; i++) {
        const a = list[i];
        for (let j = i + 1; j < total - 2; j++) {
          const b = list[j];
          for (let k = j + 1; k < total - 1; k++) {
            const c = list[k];
            for (let l = k + 1; l < total; l++) {
              const d = list[l];
              const combos = [
                [[a, b], [c, d]],
                [[a, c], [b, d]],
                [[a, d], [b, c]],
              ];
              for (const combo of combos) {
                const teamAPlayers = combo[0];
                const teamBPlayers = combo[1];
                const pairA = getPairMetric(teamAPlayers[0].id, teamAPlayers[1].id);
                const pairB = getPairMetric(teamBPlayers[0].id, teamBPlayers[1].id);
                const closeness = Math.abs(pairA.strength - pairB.strength);
                const avgGepto = (pairA.gepto + pairB.gepto) / 2;
                const avgPlayers = (pairA.avgPlayerRating + pairB.avgPlayerRating) / 2;
                const synergy = (pairA.synergyGap + pairB.synergyGap) / 2;
                const experience = pairA.matches + pairB.matches;
                const score = closeness * 1.35 + synergy * 0.35 - avgGepto * 0.5 - avgPlayers * 0.2 - experience * 0.02;
                suggestions.push({
                  score,
                  closeness,
                  avgGepto,
                  synergy,
                  experience,
                  teamA: { metric: pairA, players: teamAPlayers },
                  teamB: { metric: pairB, players: teamBPlayers },
                });
              }
            }
          }
        }
      }

      suggestions.sort((a,b)=>
        a.score - b.score ||
        a.closeness - b.closeness ||
        b.avgGepto - a.avgGepto
      );

      return suggestions.slice(0, 200);
    }

    // ---------------- UI ----------------
    function draw({players,matches,standAll}){
      const canEdit=!!API.key;
      const root=$("#root"); root.innerHTML="";

      // Header
      const head=T(`
        <header class="mb-4 flex items-center gap-3 flex-wrap">
          <img src="./icon-192.png" class="w-12 h-12 rounded-2xl border" alt="GEP&Padel"/>
          <div class="flex-1 min-w-[240px]">
            <h1 class="text-xl font-bold">GEP&Padel</h1>
            <p class="text-sm text-neutral-500">Clasificación individual y por parejas • BD compartida</p>
          </div>
          <div class="flex items-center gap-2">
            <input id="apiKey" class="px-3 py-2 rounded-xl border border-neutral-300 text-sm" placeholder="Clave de edición" value="${API.key}"/>
            <button id="saveCfg" class="btn-soft">Guardar</button>
          </div>
        </header>`);
      root.appendChild(head);
      head.querySelector("#saveCfg").onclick=(e)=>spin(e.currentTarget, async ()=>{
        API.key=head.querySelector("#apiKey").value.trim(); await init();
      });

      // ------ Clasificación ------
      const sel=T(`
        <div class="mb-3 flex items-center gap-3">
          <h2 class="text-lg font-semibold">Clasificación</h2>
          <div class="ml-auto flex gap-1">
            <button id="tabInd" class="px-3 py-1 rounded-full border bg-white">Individual</button>
            <button id="tabPair" class="px-3 py-1 rounded-full border">Parejas</button>
          </div>
        </div>`);
      root.appendChild(sel);

      const tableWrap=T(`<div class="overflow-x-auto rounded-2xl border border-neutral-200 bg-white"></div>`);
      root.appendChild(tableWrap);

      const sortState = {
        ind: { key: 'puntos', dir: 'desc' },
        pair: { key: 'puntos', dir: 'desc' },
      };
      const SORTABLE_COLUMNS = [
        { key: 'puntos', label: 'Puntos' },
        { key: 'pj', label: 'PJ' },
        { key: 'pg', label: 'PG' },
        { key: 'pp', label: 'PP' },
        { key: 'jg', label: 'JG' },
        { key: 'jp', label: 'JP' },
        { key: 'dif', label: 'Dif' },
        { key: 'geptomic', label: 'GEPTomic' },
      ];
      const asNumber = (value) => {
        if (value === null || value === undefined) return 0;
        if (typeof value === 'number') return value;
        const parsed = parseFloat(String(value).replace(',', '.'));
        return Number.isNaN(parsed) ? 0 : parsed;
      };
      const getSortValue = (row, key) => {
        if (key === 'dif') return asNumber(row.jg) - asNumber(row.jp);
        return asNumber(row[key]);
      };
      const buildGeptomicCell = (row, currentPos) => {
        const prevPos = row.prev_position ?? currentPos;
        const prevGeptomic = row.prev_geptomic ?? 0;
        let icon = '=';
        let color = 'text-orange-500';
        if (prevPos > currentPos) {
          icon = '▲';
          color = 'text-green-600';
        } else if (prevPos < currentPos) {
          icon = '▼';
          color = 'text-red-600';
        }
        return `
          <div class="flex flex-col items-center leading-tight">
            <div>${row.geptomic}</div>
            <div class="flex items-center gap-1 text-xs ${color}">
              <span>${icon}</span>
              <span class="text-[0.7rem]">${prevGeptomic}</span>
            </div>
          </div>`;
      };

      const paintTable=(mode='ind')=>{
        const rawRows = mode==='ind' ? (standAll.individual||standAll) : (standAll.parejas||[]);
        const rows = Array.isArray(rawRows) ? [...rawRows] : [];
        const state = sortState[mode] || (sortState[mode] = { key: null, dir: 'desc' });

        if (state.key) {
          rows.sort((a,b)=>{
            const va = getSortValue(a, state.key);
            const vb = getSortValue(b, state.key);
            return state.dir === 'desc' ? vb - va : va - vb;
          });
        }

        const thead = (()=>{
          const nameLabel = mode==='ind' ? 'Jugador/a' : 'Pareja';
          const cells = SORTABLE_COLUMNS.map(col=>{
            const active = state.key === col.key;
            const arrow = active ? (state.dir === 'desc' ? '▼' : '▲') : '';
            return `<th class="px-4 py-3 text-center cursor-pointer select-none" data-sort="${col.key}">${col.label}${arrow ? ` <span class="inline-block text-xs">${arrow}</span>` : ''}</th>`;
          }).join('');
          return `<thead class="bg-neutral-50"><tr>` +
            `<th class="px-4 py-3 text-left">#</th>` +
            `<th class="px-4 py-3 text-left">${nameLabel}</th>` +
            cells +
          `</tr></thead>`;
        })();

        const tbody = document.createElement('tbody');
        rows.forEach((r,i)=>{
          const diffVal = asNumber(r.jg) - asNumber(r.jp);
          const diffText = `${diffVal >= 0 ? '+' : ''}${diffVal}`;
          const diffClass = diffVal >= 0 ? 'text-green-600' : 'text-red-600';
          const geptomicCell = buildGeptomicCell(r, i + 1);
          if(mode==='ind'){
            tbody.appendChild(T(
              `<tr class="border-t border-neutral-100 row">
                 <td class="px-4 py-3 font-medium">${i+1}</td>
                 <td class="px-4 py-3 flex items-center gap-2">${miniAvatar((r.photo_base64||r.photo),r.name)} ${r.name}${r.alias?` <span class="text-neutral-500">(${r.alias})</span>`:''}</td>
                 <td class="px-4 py-3 font-semibold text-center">${r.puntos}</td>
                 <td class="px-4 py-3 text-center">${r.pj}</td>
                 <td class="px-4 py-3 text-center">${r.pg}</td>
                 <td class="px-4 py-3 text-center">${r.pp}</td>
                 <td class="px-4 py-3 text-center">${r.jg}</td>
                 <td class="px-4 py-3 text-center">${r.jp}</td>
                 <td class="px-4 py-3 text-center font-semibold ${diffClass}">${diffText}</td>
                 <td class="px-4 py-3 text-center">${geptomicCell}</td>
               </tr>`
            ));
          }else{
            const [p1,p2]=r.photos||['',''];
            tbody.appendChild(T(
              `<tr class="border-t border-neutral-100 row">
                 <td class="px-4 py-3 font-medium">${i+1}</td>
                 <td class="px-4 py-3 flex items-center gap-2">
                    ${miniAvatar(p1,'')} <span class="font-bold">+</span> ${miniAvatar(p2,'')}
                    <span class="ml-2">${r.name}</span>
                 </td>
                 <td class="px-4 py-3 font-semibold text-center">${r.puntos}</td>
                 <td class="px-4 py-3 text-center">${r.pj}</td>
                 <td class="px-4 py-3 text-center">${r.pg}</td>
                 <td class="px-4 py-3 text-center">${r.pp}</td>
                 <td class="px-4 py-3 text-center">${r.jg}</td>
                 <td class="px-4 py-3 text-center">${r.jp}</td>
                 <td class="px-4 py-3 text-center font-semibold ${diffClass}">${diffText}</td>
                 <td class="px-4 py-3 text-center">${geptomicCell}</td>
               </tr>`
            ));
          }
        });

        tableWrap.innerHTML = `<table class="min-w-full text-sm">${thead}</table>`;
        const tableEl = tableWrap.querySelector('table');
        tableEl.appendChild(tbody);
        tableEl.querySelectorAll('th[data-sort]').forEach(th=>{
          th.addEventListener('click',()=>{
            const key = th.dataset.sort;
            if (!key) return;
            if (state.key === key) {
              state.dir = state.dir === 'desc' ? 'asc' : 'desc';
            } else {
              state.key = key;
              state.dir = 'desc';
            }
            paintTable(mode);
          });
        });
      };
      paintTable('ind');
      sel.querySelector('#tabInd').onclick=()=>{ sel.querySelector('#tabInd').classList.add('bg-white'); sel.querySelector('#tabPair').classList.remove('bg-white'); paintTable('ind'); };
      sel.querySelector('#tabPair').onclick=()=>{ sel.querySelector('#tabPair').classList.add('bg-white'); sel.querySelector('#tabInd').classList.remove('bg-white'); paintTable('pair'); };

      root.appendChild(T(`<div class="mt-8"></div>`));

      const recSec=T(`
        <section class="mb-6">
          <div class="rounded-2xl border border-neutral-200 bg-white p-4">
            <div class="flex flex-wrap items-center justify-between gap-2">
              <h3 class="font-semibold">Partido recomendado</h3>
              <button type="button" class="btn-soft" data-rec-refresh>Busca otras parejas</button>
            </div>
            <button type="button" class="w-full mt-3 border border-neutral-200 rounded-2xl px-4 py-3 bg-neutral-50 hover:bg-neutral-100 transition-colors" data-rec-accept>
              <div class="text-xs uppercase tracking-wide text-neutral-500 mb-2">Siguiente partido recomendado</div>
              <div class="flex flex-wrap items-center justify-center gap-3 text-sm font-medium" data-rec-display></div>
            </button>
            <p class="text-sm text-neutral-400 mt-2 hidden" data-rec-empty>No hay suficientes jugadores disponibles para sugerir un partido.</p>
          </div>
        </section>`);
      root.appendChild(recSec);

      const recDisplay = recSec.querySelector('[data-rec-display]');
      const recAccept = recSec.querySelector('[data-rec-accept]');
      const recRefresh = recSec.querySelector('[data-rec-refresh]');
      const recEmpty = recSec.querySelector('[data-rec-empty]');
      const recSuggestions = computeMatchSuggestions(players, matches, standAll);
      let recIndex = 0;
      let applySuggestionToTeams = () => {};

      const renderTeam = (team) => {
        if (!team || !Array.isArray(team.players) || team.players.length < 2) return '';
        const [p1, p2] = team.players;
        const name1 = escAttr((p1 && (p1.alias || p1.name)) || '¿?');
        const name2 = escAttr((p2 && (p2.alias || p2.name)) || '¿?');
        const avatar1 = miniAvatar((p1 && (p1.photo_base64 || p1.photo)) || '', p1 ? p1.name : '');
        const avatar2 = miniAvatar((p2 && (p2.photo_base64 || p2.photo)) || '', p2 ? p2.name : '');
        return `<span class="inline-flex items-center gap-2">${avatar1}<span>${name1}</span><span class="font-semibold text-neutral-400">+</span>${avatar2}<span>${name2}</span></span>`;
      };

      const updateRefreshState = () => {
        const disable = recSuggestions.length <= 1;
        recRefresh.disabled = disable;
        recRefresh.classList.toggle('opacity-50', disable);
        recRefresh.classList.toggle('cursor-not-allowed', disable);
      };

      const renderRecommendation = () => {
        const suggestion = recSuggestions[recIndex] || null;
        if (!suggestion) {
          recDisplay.innerHTML = `<span class="text-sm text-neutral-400">No hay suficientes jugadores disponibles para sugerir un partido.</span>`;
          recAccept.disabled = true;
          recAccept.classList.add('opacity-50','cursor-not-allowed');
          if (recEmpty) recEmpty.classList.remove('hidden');
        } else {
          recDisplay.innerHTML = `${renderTeam(suggestion.teamA)}<span class="mx-3 font-semibold text-neutral-400">vs</span>${renderTeam(suggestion.teamB)}`;
          recAccept.disabled = false;
          recAccept.classList.remove('opacity-50','cursor-not-allowed');
          if (recEmpty) recEmpty.classList.add('hidden');
        }
        updateRefreshState();
      };

      renderRecommendation();

      recRefresh.onclick=()=>{
        if (recSuggestions.length <= 1) return;
        recIndex = (recIndex + 1) % recSuggestions.length;
        renderRecommendation();
      };

      recAccept.onclick=()=>{
        const suggestion = recSuggestions[recIndex];
        if (!suggestion) return;
        applySuggestionToTeams(suggestion);
      };

      // ------ Crear partido ------
      const courtOptions = COURTS.map(c=>`<option value="${c.id}">${c.name}</option>`).join('');
      const sec=T(`<section class="mb-6 grid gap-4">
        <div class="rounded-2xl border border-neutral-200 bg-white p-4">
          <h3 class="font-semibold mb-3">Crear Nuevo Partido</h3>
          <div class="grid md:grid-cols-2 gap-3">
            <input id="fecha" type="datetime-local" class="px-3 py-2 rounded-xl border border-neutral-300" />
            <select id="court" class="px-3 py-2 rounded-xl border border-neutral-300">
              <option value="">Selecciona pista</option>
              ${courtOptions}
            </select>
          </div>
          <div class="grid md:grid-cols-2 gap-3 mt-3">
            <div><div class="text-sm text-neutral-500 mb-1">Equipo A (2 jugadores)</div><div id="teamA" class="grid grid-cols-2 gap-2"></div></div>
            <div><div class="text-sm text-neutral-500 mb-1">Equipo B (2 jugadores)</div><div id="teamB" class="grid grid-cols-2 gap-2"></div></div>
          </div>
          <textarea id="coment" class="mt-3 px-3 py-2 rounded-xl border border-neutral-300 w-full min-h-[80px]" placeholder="Comentarios"></textarea>
          <div class="mt-3 flex items-center gap-2">
            <button id="createMatch" class="${canEdit?'btn-dark':'btn-soft text-neutral-400 cursor-not-allowed'}">Crear Nuevo Partido</button>
          </div>
        </div>
      </section>`);
      root.appendChild(sec);

      // selección con oscurecido
      const pick = j => T(`
        <button data-id="${j.id}" class="px-3 py-2 rounded-xl border border-neutral-300 text-left flex items-center gap-2 transition-colors">
          ${miniAvatar(j.photo_base64 || j.photo, j.name)}
          <span class="player-name">${j.name}${j.alias?` (${j.alias})`:""}</span>
        </button>`);
      const teamA=sec.querySelector("#teamA"), teamB=sec.querySelector("#teamB");
      const selA=new Set(), selB=new Set();
      function toggle(btn,set,id,other){
        if (set.has(id)) { set.delete(id); btn.classList.remove('pick-active'); }
        else { if(set.size>=2 || other.has(id)) return; set.add(id); btn.classList.add('pick-active'); }
      }
      players.forEach(j=>{
        const a=pick(j), b=pick(j);
        a.onclick=()=>{ if(!canEdit) return; toggle(a,selA,j.id,selB); };
        b.onclick=()=>{ if(!canEdit) return; toggle(b,selB,j.id,selA); };
        teamA.appendChild(a); teamB.appendChild(b);
      });

      applySuggestionToTeams = (suggestion) => {
        if (!suggestion) return;
        const teamAPlayers = (suggestion.teamA && Array.isArray(suggestion.teamA.players)) ? suggestion.teamA.players : [];
        const teamBPlayers = (suggestion.teamB && Array.isArray(suggestion.teamB.players)) ? suggestion.teamB.players : [];
        if (teamAPlayers.length < 2 || teamBPlayers.length < 2) return;

        selA.clear();
        selB.clear();

        const idsA = new Set(teamAPlayers.map(p => String(p.id)));
        const idsB = new Set(teamBPlayers.map(p => String(p.id)));

        teamA.querySelectorAll('button').forEach(btn => {
          const idStr = btn.dataset.id;
          if (idsA.has(idStr)) {
            btn.classList.add('pick-active');
            const player = teamAPlayers.find(p => String(p.id) === idStr);
            selA.add(player ? player.id : idStr);
          } else {
            btn.classList.remove('pick-active');
          }
        });

        teamB.querySelectorAll('button').forEach(btn => {
          const idStr = btn.dataset.id;
          if (idsB.has(idStr)) {
            btn.classList.add('pick-active');
            const player = teamBPlayers.find(p => String(p.id) === idStr);
            selB.add(player ? player.id : idStr);
          } else {
            btn.classList.remove('pick-active');
          }
        });

        if (typeof sec.scrollIntoView === 'function') {
          sec.scrollIntoView({ behavior:'smooth', block:'start' });
        }
      };

      sec.querySelector("#createMatch").onclick=async (ev)=>{
        if(!canEdit) return alert("Introduce la clave de edición.");
        if(selA.size!==2 || selB.size!==2) return alert("Cada equipo debe tener 2 jugadores.");
        const courtSel = sec.querySelector("#court");
        const court = COURTS.find(c=>c.id===courtSel.value);
        if(!court) return alert("Selecciona una pista.");
        const fechaInput = sec.querySelector("#fecha");
        const fechaVal = (fechaInput?.value || '').trim();
        if(!fechaVal){
          alert('Selecciona fecha y hora en el calendario.');
          fechaInput?.focus();
          return;
        }
        if(Number.isNaN(new Date(fechaVal).getTime())){
          alert('La fecha indicada no es válida.');
          fechaInput?.focus();
          return;
        }
        const fecha = fechaVal;
        const coment=sec.querySelector("#coment").value.trim();
        const [a1,a2]=[...selA], [b1,b2]=[...selB];
        try {
          await spin(ev.currentTarget, async ()=>{
            await API.post('/.netlify/functions/create-match',{dateISO:fecha,a1,a2,b1,b2,comment:coment,court_name:court.name,court_email:court.email});
          });
          await init();
        } catch(err) {
          alert(`No se pudo crear el partido: ${parseError(err)}`);
        }
      };

      // -------- Histórico de partidos --------
      root.appendChild(T(`<h3 class="text-lg font-semibold mt-6 mb-2">Histórico de partidos</h3>`));
      const listWrap=T(`<div class="grid gap-6" id="matchesList"></div>`);
      root.appendChild(listWrap);

      const P = id => players.find(p=>p.id===id);
      const statusPill = (fin) =>
        fin ? `<span class="text-emerald-600">Finalizado</span>` : `<span class="text-amber-600">Pendiente</span>`;

      const setRow=(id,idx,vals={a:0,b:0})=>{
        const el=T(`<div class="flex items-center gap-3">
          <input type="number" min="0" class="w-16 text-center px-2 py-2 rounded-xl border border-neutral-300" id="sa${idx}-${id}" value="${vals.a??0}">
          <span class="text-center text-sm text-neutral-500 w-10">Set ${idx}</span>
          <input type="number" min="0" class="w-16 text-center px-2 py-2 rounded-xl border border-neutral-300" id="sb${idx}-${id}" value="${vals.b??0}">
        </div>`);
        const mark=()=>{
          const a=+el.querySelector(`#sa${idx}-${id}`).value||0;
          const b=+el.querySelector(`#sb${idx}-${id}`).value||0;
          el.querySelector(`#sa${idx}-${id}`).classList.toggle('cell-win', a>b);
          el.querySelector(`#sb${idx}-${id}`).classList.toggle('cell-win', b>a);
        };
        el.oninput=mark; mark(); return el;
      };

      const formatMonthLabel = (date) => {
        if (!date) return 'Sin fecha';
        const month = date.toLocaleDateString('es-ES', { month:'long' });
        return month.charAt(0).toUpperCase() + month.slice(1);
      };

      const getGroupInfo = (match) => {
        const rawDate = match?.date_iso ? new Date(match.date_iso) : null;
        if (!rawDate || Number.isNaN(rawDate.getTime())) {
          return {
            yearKey: 'sin-fecha',
            yearLabel: 'Sin fecha',
            monthKey: 'sin-fecha',
            monthLabel: 'Sin fecha',
            sortValue: 0,
          };
        }
        const year = String(rawDate.getFullYear());
        const monthKey = `${year}-${String(rawDate.getMonth() + 1).padStart(2, '0')}`;
        return {
          yearKey: year,
          yearLabel: year,
          monthKey,
          monthLabel: formatMonthLabel(rawDate),
          sortValue: rawDate.getTime(),
        };
      };

      const renderMatchCard = (m) => {
        const a1=P(m.a1), a2=P(m.a2), b1=P(m.b1), b2=P(m.b2);
        const participants = [a1, a2, b1, b2].filter(Boolean);
        const isPast = isPastMatch(m.date_iso);
        const courtName = m.court_name || (isPast ? 'Padel 1 Sabadell' : '');
        const card=T(`<div class="rounded-2xl border border-neutral-200 bg-white p-4">
          <div class="flex flex-wrap items-start justify-between gap-3 text-sm mb-3">
            <div class="grid gap-2">
              <div class="text-neutral-500">${formatDT(m.date_iso)}</div>
              ${(!m.finalizado && canEdit) ? `
                <div class="flex flex-wrap gap-2 items-center">
                  <input type="datetime-local" id="date-${m.id}" class="px-3 py-2 rounded-xl border border-neutral-300" value="${formatDateForInput(m.date_iso)}" aria-label="Fecha del partido">
                  <button class="btn-soft" id="save-date-${m.id}">${m.date_iso ? 'Actualizar fecha' : 'Guardar fecha'}</button>
                </div>
              `:''}
            </div>
            <div>${statusPill(m.finalizado)}</div>
          </div>

          <div class="flex items-center gap-2 mb-3">
            <div class="flex items-center gap-2">
              ${miniAvatar(a1?.photo_base64||a1?.photo,a1?.name)} ${a1?.name||'¿?'} <span class="mx-1">+</span>
              ${miniAvatar(a2?.photo_base64||a2?.photo,a2?.name)} ${a2?.name||'¿?'}
            </div>
            <div class="mx-3 font-semibold">vs</div>
            <div class="flex items-center gap-2">
              ${miniAvatar(b1?.photo_base64||b1?.photo,b1?.name)} ${b1?.name||'¿?'} <span class="mx-1">+</span>
              ${miniAvatar(b2?.photo_base64||b2?.photo,b2?.name)} ${b2?.name||'¿?'}
            </div>
          </div>

          <div class="grid md:grid-cols-[1fr_420px] gap-6 items-start">
            <div class="grid gap-2">
              ${setRow(m.id,1,{a:m.s1a,b:m.s1b}).outerHTML}
              ${setRow(m.id,2,{a:m.s2a,b:m.s2b}).outerHTML}
              ${setRow(m.id,3,{a:m.s3a,b:m.s3b}).outerHTML}
              <div class="flex items-center gap-2">
                <button class="${canEdit?'btn-dark':'btn-soft text-neutral-400'}" id="close-${m.id}">Cerrar resultado</button>
                <button class="btn-soft" id="del-${m.id}">Eliminar partido</button>
              </div>
            </div>

            <div class="grid gap-2">
              <div class="text-sm text-neutral-600">
                ${courtName
                  ? `<span class="font-medium">Pista:</span> ${courtName}${m.court_email?` • ${escAttr(m.court_email)}`:''}`
                  : '<span class="text-amber-600 font-medium">Pista pendiente de asignar</span>'}
              </div>
              ${isPast ? `<div class="text-xs text-neutral-500">Los envíos de correo están deshabilitados para partidos anteriores a hoy.</div>` : ''}
              ${(!m.finalizado && m.reservation_sent)?`<div class="text-xs font-medium text-emerald-600">Reserva Pista Enviada</div>`:''}
              ${(!m.finalizado && m.calendar_sent)?`<div class="text-xs font-medium text-sky-600">Invitaciones enviadas</div>`:''}
              ${!m.finalizado ? `
                <div class="flex flex-wrap gap-2">
                  <button class="btn-soft" id="reserve-${m.id}">Reservar Pista</button>
                  <button class="btn-soft" id="calendar-${m.id}">Enviar Calendar</button>
                </div>
              `:''}
              ${m.photo_base64?`<img src="${m.photo_base64}" class="rounded-xl border max-w-[420px] max-h-[240px] object-cover"/>`:''}
              ${!m.finalizado ? `
                <div class="flex items-center gap-2">
                  <input type="file" id="ph-${m.id}" accept="image/*" class="text-sm">
                  <button class="btn-soft" id="up-${m.id}">Subir foto</button>
                </div>
              `:''}
              <textarea id="com-${m.id}" class="px-3 py-2 rounded-xl border border-neutral-300 w-full min-h-[96px]" placeholder="Comentario" ${canEdit?'':'disabled'}>${m.comment||''}</textarea>
            </div>
          </div>
        </div>`);

        const dateInput = card.querySelector(`#date-${m.id}`);
        const saveDateBtn = card.querySelector(`#save-date-${m.id}`);
        if(saveDateBtn){
          saveDateBtn.onclick=async (ev)=>{
            if(!canEdit) return alert("Introduce la clave de edición.");
            if(!dateInput) return;
            const value = (dateInput.value || '').trim();
            if(!value){
              alert('Introduce una fecha para guardar.');
              dateInput.focus();
              return;
            }
            if(Number.isNaN(new Date(value).getTime())){
              alert('La fecha indicada no es válida.');
              dateInput.focus();
              return;
            }
            try {
              await spin(ev.currentTarget, async ()=>{
                await API.post('/.netlify/functions/update-match-date',{ id:m.id, dateISO:value });
              });
              alert('Fecha actualizada ✅');
              await init();
            } catch(err) {
              alert(`No se pudo actualizar la fecha: ${parseError(err)}`);
            }
          };
        }

        const reserveBtn = card.querySelector(`#reserve-${m.id}`);
        if(reserveBtn){
          if(isPast){
            reserveBtn.disabled = true;
            reserveBtn.classList.add('opacity-50','cursor-not-allowed');
            reserveBtn.title = 'Solo disponible para partidos futuros.';
          } else {
            reserveBtn.onclick=async (ev)=>{
              if(!canEdit) return alert("Introduce la clave de edición.");
              if(!m.court_email){
                alert('No hay correo de pista configurado.');
                return;
              }
              if(!m.date_iso){
                alert('Configura la fecha del partido en el calendario antes de reservar la pista.');
                return;
              }
              const { date, time } = formatDateParts(m.date_iso);
              const defaultMsg = `¡Hola!\n\nNos gustaría reservar una pista para el día ${date} y la hora ${time}.\nSi tenéis espacio, nos podrías confirmar el número de pista por favor.\nLa reserva la ponemos a nombre de Julio de GEP (es el nombre de la empresa)\n\nMuchas gracias por adelantado.`;
              const message = await openTextModal({ title: 'Correo de reserva', defaultValue: defaultMsg, confirmLabel: 'Enviar correo' });
              if(!message) return;
              try {
                await spin(ev.currentTarget, async ()=>{
                  await API.post('/.netlify/functions/send-reservation',{ matchId:m.id, message });
                });
                alert('Correo enviado ✅');
                await init();
              } catch(err) {
                alert(`No se pudo enviar el correo: ${parseError(err)}`);
              }
            };
          }
        }

        const calendarBtn = card.querySelector(`#calendar-${m.id}`);
        if(calendarBtn){
          if(isPast){
            calendarBtn.disabled = true;
            calendarBtn.classList.add('opacity-50','cursor-not-allowed');
            calendarBtn.title = 'Solo disponible para partidos futuros.';
          } else {
            calendarBtn.onclick=async (ev)=>{
              if(!canEdit) return alert("Introduce la clave de edición.");
              if(!m.date_iso){
                alert('Configura la fecha del partido en el calendario antes de enviar invitaciones.');
                return;
              }
              const emailPlayers = participants.filter(p=>p.email);
              if(emailPlayers.length===0){
                alert('Ningún participante tiene email configurado.');
                return;
              }
              if(!m.reservation_sent){
                const ok = confirm('¿Tenéis la pista reservada ya?');
                if(!ok){
                  alert('No se enviará hasta que no haya pista.');
                  return;
                }
              }
              try {
                await spin(ev.currentTarget, async ()=>{
                  await API.post('/.netlify/functions/send-calendar',{ matchId:m.id });
                });
                alert('Invitaciones enviadas ✅');
                await init();
              } catch(err) {
                alert(`No se pudieron enviar las invitaciones: ${parseError(err)}`);
              }
            };
          }
        }

        // Subir foto
        const upBtn = card.querySelector(`#up-${m.id}`);
        if(upBtn){
          upBtn.onclick=(e)=>spin(e.currentTarget, async()=>{
            if(!canEdit) return alert("Introduce la clave de edición.");
            const f=card.querySelector(`#ph-${m.id}`).files?.[0];
            if(!f) return alert('Selecciona una imagen.');
            const photo = await compressImage(f, 1400, 0.82);
            await API.post('/.netlify/functions/update-match-photo',{id:m.id,photo_base64:photo});
            await init();
          });
        }

        // Cerrar resultado
        card.querySelector(`#close-${m.id}`).onclick=(e)=>spin(e.currentTarget, async()=>{
          if(!canEdit) return alert("Introduce la clave de edición.");
          const s = [1,2,3].map(i=>({
            a:Number(card.querySelector(`#sa${i}-${m.id}`).value)||0,
            b:Number(card.querySelector(`#sb${i}-${m.id}`).value)||0
          }));
          await API.put('/.netlify/functions/close-result',{id:m.id,sets:s,comment:card.querySelector(`#com-${m.id}`).value});
          await init();
        });

        // Eliminar partido (contraseña oculta)
        card.querySelector(`#del-${m.id}`).onclick=(e)=>spin(e.currentTarget, async()=>{
          if(!canEdit) return alert("Introduce la clave de edición.");
          const pass = prompt('Escribe la contraseña para eliminar');
          if(!pass) return;
          if(pass.trim()!=='eliminar') return alert('Contraseña incorrecta.');
          if(!confirm('¿Eliminar partido? Esta acción no se puede deshacer.')) return;
          await API.post('/.netlify/functions/delete-match',{id:m.id});
          await init();
        });

        return card;
      };

      if(matches.length===0){
        listWrap.appendChild(T(`<div class="text-neutral-500">No hay partidos aún.</div>`));
      } else {
        const pendingMatches = matches.filter(m=>!m.finalizado);
        const finishedMatches = matches.filter(m=>m.finalizado);

        const pendingSection = T(`<div class="grid gap-3"></div>`);
        pendingSection.appendChild(T(`<h4 class="text-base font-semibold">Partidos pendientes</h4>`));
        if(pendingMatches.length===0){
          pendingSection.appendChild(T(`<div class="text-neutral-500">No hay partidos pendientes.</div>`));
        } else {
          pendingMatches.forEach(m=>pendingSection.appendChild(renderMatchCard(m)));
        }
        listWrap.appendChild(pendingSection);

        const finishedSection = T(`<div class="grid gap-3"></div>`);
        finishedSection.appendChild(T(`<h4 class="text-base font-semibold">Partidos cerrados</h4>`));
        if(finishedMatches.length===0){
          finishedSection.appendChild(T(`<div class="text-neutral-500">Aún no hay partidos cerrados.</div>`));
        } else {
          const sortedFinished = [...finishedMatches].sort((a, b) => {
            const infoA = getGroupInfo(a);
            const infoB = getGroupInfo(b);
            return infoB.sortValue - infoA.sortValue;
          });

          const grouped = new Map();
          const yearOrder = [];
          sortedFinished.forEach((match) => {
            const info = getGroupInfo(match);
            if (!grouped.has(info.yearKey)) {
              grouped.set(info.yearKey, { label: info.yearLabel, months: new Map(), monthOrder: [] });
              yearOrder.push(info.yearKey);
            }
            const yearGroup = grouped.get(info.yearKey);
            if (!yearGroup.months.has(info.monthKey)) {
              yearGroup.months.set(info.monthKey, { label: info.monthLabel, matches: [] });
              yearGroup.monthOrder.push(info.monthKey);
            }
            yearGroup.months.get(info.monthKey).matches.push(match);
          });

          yearOrder.forEach((yearKey) => {
            const yearGroup = grouped.get(yearKey);
            const totalMatches = yearGroup.monthOrder.reduce((sum, monthKey) => {
              return sum + yearGroup.months.get(monthKey).matches.length;
            }, 0);
            const yearDetails = T(`
              <details class="rounded-2xl border border-neutral-200 bg-white overflow-hidden">
                <summary class="cursor-pointer select-none px-4 py-3 flex items-center justify-between">
                  <span class="font-semibold">${yearGroup.label}</span>
                  <span class="text-sm text-neutral-500">${totalMatches} partido${totalMatches===1?'':'s'}</span>
                </summary>
                <div class="px-4 pb-4 grid gap-3"></div>
              </details>
            `);
            const yearBody = yearDetails.querySelector('div');
            yearGroup.monthOrder.forEach((monthKey) => {
              const monthGroup = yearGroup.months.get(monthKey);
              const monthDetails = T(`
                <details class="rounded-xl border border-neutral-200 bg-neutral-50 overflow-hidden">
                  <summary class="cursor-pointer select-none px-4 py-3 flex items-center justify-between">
                    <span class="font-medium">${monthGroup.label}</span>
                    <span class="text-sm text-neutral-500">${monthGroup.matches.length} partido${monthGroup.matches.length===1?'':'s'}</span>
                  </summary>
                  <div class="px-4 pb-4 grid gap-3"></div>
                </details>
              `);
              const monthBody = monthDetails.querySelector('div');
              monthGroup.matches.forEach(match => monthBody.appendChild(renderMatchCard(match)));
              yearBody.appendChild(monthDetails);
            });
            finishedSection.appendChild(yearDetails);
          });
        }
        listWrap.appendChild(finishedSection);
      }

      // ------ Gestión de jugadores ------
      const secP=T(`<section class="mt-6 grid gap-4">
        <div class="rounded-2xl border border-neutral-200 bg-white p-4">
          <h3 class="font-semibold mb-3">Añadir jugador/a</h3>
          <div class="flex flex-col md:flex-row gap-2">
            <input id="name" class="flex-1 px-3 py-2 rounded-xl border border-neutral-300" placeholder="Nombre y apellidos" />
            <input id="alias" class="flex-1 px-3 py-2 rounded-xl border border-neutral-300" placeholder="Alias (opcional)" />
            <input id="email" type="email" class="flex-1 px-3 py-2 rounded-xl border border-neutral-300" placeholder="Email (opcional)" />
            <button id="add" class="${canEdit?'btn-dark':'btn-soft text-neutral-400'}">Añadir</button>
          </div>
        </div>
        <div class="rounded-2xl border border-neutral-200 bg-white">
          <div class="p-4 flex items-center justify-between"><h3 class="font-semibold">Jugadores/as (${players.length})</h3></div>
          <ul class="divide-y" id="plist"></ul>
        </div>
      </section>`);
      root.appendChild(secP);

      secP.querySelector("#add").onclick=async (ev)=>{
        if(!canEdit) return alert("Introduce la clave de edición.");
        const name=secP.querySelector("#name").value.trim();
        const alias=secP.querySelector("#alias").value.trim();
        const email=secP.querySelector("#email").value.trim();
        if(!name) return;
        try {
          await spin(ev.currentTarget, async()=>{
            await API.post('/.netlify/functions/add-player',{name,alias,email});
          });
          await init();
        } catch(err) {
          alert(`No se pudo añadir el jugador: ${parseError(err)}`);
        }
      };

      const plist=secP.querySelector("#plist");
      players.forEach(j=>{
        const row=T(
        `<li class="p-4 grid md:grid-cols-[auto_1fr_auto] items-center gap-3">
          <img class="avatar" src="${(j.photo_base64||j.photo)||'/icon-192.png'}" onerror="this.src='${AVA_FALLBACK}'" alt="${j.name}">
          <div>
            <div class="font-medium">${j.name}</div>
            ${j.alias? `<div class="text-sm text-neutral-500">Alias: ${j.alias}</div>`:''}
            ${j.email? `<div class="text-sm text-neutral-500">Email: ${j.email}</div>`:''}
            <div class="mt-2 flex flex-wrap items-center gap-2 ${canEdit?'':'opacity-50 pointer-events-none'}">
              <input type="text" class="px-2 py-1 rounded-lg border" placeholder="Nuevo nombre" id="nn-${j.id}">
              <input type="text" class="px-2 py-1 rounded-lg border" placeholder="Nuevo alias" id="na-${j.id}">
              <input type="email" class="px-2 py-1 rounded-lg border" placeholder="Nuevo email" id="ne-${j.id}" value="${escAttr(j.email||'')}">
              <input type="file" accept="image/*" id="np-${j.id}">
              <button class="btn-soft" id="save-${j.id}">Guardar cambios</button>
            </div>
          </div>
          <button data-id="${j.id}" class="text-sm btn-soft">Eliminar</button>
        </li>`);
        row.querySelector(`#save-${j.id}`).onclick=async (ev)=>{
          if(!canEdit) return;
          const name=row.querySelector(`#nn-${j.id}`).value.trim();
          const alias=row.querySelector(`#na-${j.id}`).value.trim();
          const emailInput=row.querySelector(`#ne-${j.id}`);
          const emailVal=emailInput?emailInput.value.trim():'';
          const originalEmail=(j.email||'').trim();
          const f=row.querySelector(`#np-${j.id}`).files?.[0];
          let photo=null; if(f) photo=await compressImage(f, 900, 0.85);
          const payload={ id:j.id };
          if(name) payload.name=name;
          if(alias) payload.alias=alias;
          if(photo) payload.photo_base64=photo;
          if(emailInput && emailVal!==originalEmail) payload.email=emailVal;
          if(Object.keys(payload).length===1 && !payload.email){
            alert('Introduce algún cambio antes de guardar.');
            return;
          }
          try {
            await spin(ev.currentTarget, async()=>{
              await API.post('/.netlify/functions/update-player',payload);
            });
            alert('Cambios guardados ✅');
            await init();
          } catch(err) {
            alert(`No se pudieron guardar los cambios: ${parseError(err)}`);
          }
        };
        row.querySelector("button[data-id]").onclick=(e)=>spin(e.currentTarget, async()=>{
          if(!canEdit) return alert("Introduce la clave de edición.");
          if(!confirm("Eliminar jugador/a?")) return;
          await API.post('/.netlify/functions/delete-player',{id:j.id});
          await init();
        });
        plist.appendChild(row);
      });
    }

    async function init(){
      try{ const data=await loadAll(); draw(data); }
      catch(e){
        $("#root").innerHTML = `
          <div class="p-4 rounded-2xl bg-yellow-50 border border-yellow-200 text-yellow-800">
            Primera vez: el admin debe abrir <code>/.netlify/functions/migrate?key=TU_CLAVE</code> para crear las tablas.<br>
            Error: ${e.message}
          </div>`;
      }
    }
    init();

    // PWA
    if('serviceWorker' in navigator){
      window.addEventListener('load',()=>navigator.serviceWorker.register('./sw.js').catch(()=>{}));
    }
  </script>
</body>
</html>
